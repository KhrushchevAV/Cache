package study.stepup.util;

import java.lang.reflect.Method;
import java.util.TreeMap;

// состояние объекта
// Это самый важный (и сложный, как мне показался) вопрос при кэшировании - что понимать под состоянием!
// 1) первое что приходит в голову брать состояние всех полей объекта или для простоты toString() объекта
//    у этого подхода большой минус: в состояние могут попасть поля которые не должны влиять на кэшируемый метод
//    вот попадет какой-нибудь внутренний счетчик и всё будем кэширвать каждый вызов убивая всю идею кэширования
//    да и методы @Mutator в таком раскладе теряют всякий смысл.
// 2) под сосстоянием понимать вызовы методов с аннотацией "@Mutator". Но! Мутаторы задумывались чтобы СБРАСЫВАТЬ кэш.
//    при этом совершенно не ясно, сколько мутаторов влияет на состояние объекта?! И важен ли порядок их запуска.
//    без этого мы можем закэшировать полную ерунду, например дробь с числителем 3 всегда закэширует 3/5 не понимая,
//    что еще знаменатель задавали разный.
// 3) Самое разумное imho, в таком подходе как вечно хранящиеся кэши, помечать отдельной аннотацией поля, которые
//    важны для состояния, а методы @Mutator - лишние.
//
// Ну в нашей учебной задаче сформулировано так "развить решение, полученное в результате разработки утилитного метода cache"
// что стоило многих часов на вникание :(
//
// Далее для целеей этой учебной задачи принимаем, что состояние это мапа <метод,аргументы> только для методов @Mutator
// принимая неявное допущение, что ни порядок вызовов мутаторов ни история их вызовов/(не вызовов) не влияют на результат кэшируемых методов.
// Причем, аргументы сохраняем не глубоко чтобы сильно не усложнять (это допущение оговаривалось на лекции).
//

public class State {
    // TreeMap - для того, чтобы не зависить от сортировки
    private TreeMap<String, String> methodArgMap = new TreeMap<>();

    public void changeState(Method m, Object[] args) {
        // аргументы вида "java.lang.Object;@4ae1f202" - как-то не очень
        String strArg = "";
        for (int i = 0; i < args.length; i++) {
            strArg += args[i].toString();
        }
        methodArgMap.put(m.getName(), strArg);
    }

    @Override
    public String toString() {
        String res;
        res = methodArgMap.toString();
        return res;
    }
}
