package study.stepup.util;

import lombok.ToString;

import java.lang.reflect.Method;
import java.util.HashMap;

// состояние объекта
// Это самый важный (и сложный мне показался) вопрос при кэшировании что понимать под состоянием!
// 1) первое что приходит в голову брать состояние всех полей объекта или для простоты toString() объекта
//    у этого подхода большой минус: в состояние могут попасть поля которые не должны влиять на кэшируемый метод
//    вот попадет какой-нибудь внутренний счетчик и всё будем кэширвать каждый вызов убивая всю идею кэширования
//    да и методы @Mutator в таком раскладе теряют всякий смысл.
// 2) под сосстоянием понимать вызовы методов с аннотацией "@Mutator". Но! Мутаторы задумывались чтобы СБРАСЫВАТЬ кэш.
//    при этом совершенно не ясно, сколько мутаторов влияет на состояние объекта?! И важен ли порядок их запуска.
//    без этого мы можем закэшировать полную ерунду, например дробь с числителем 3 всегда закэширует 3/5 не понимая,
//    что еще знаменатель задавали разный.
// 3) Самое разумное imho, в таком подходе как вечно хранящиеся кэши, помечать отдельной аннотацией поля, которые
//    важны для состояния, а методы @Mutator - лишние.
//
// Далее для целеей этой учебной задачи принимаем, что ссостояние это мапа <метод,аргументы> только для методов @Mutator
// принимая неявное допущение, что ни порядок вызовов мутаторов ни история их вызовов/(не вызовов) не влияют на результат кэшируемых методов.
// Причем, аргументы сохраняем не глубоко чтобы сильно не усложнять (это допущение оговаривалось на лекции).

@ToString
public class State {
    private HashMap<Method, Object[]> hashMap = new HashMap<>();

    public void changeState(Method m, Object[] args) {
        hashMap.put(m, args);
    }
}
